Национальный исследовательский университет ИТМО  
Мегафакультет компьютерных технологий и управления  
Факультет программной инженерии и компьютерной техники  

<br/>
<br/>
<br/>
<br/>
<br/>
<br/>

# Отчет по лабораторной работе №3  
по курсу «Языки программирования»

<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>

**Выполнил:**  
Студент группы P4119  
М.С. Маршалов  

**Преподаватель:**  
Ю. Д. Кореньков  

<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>

Санкт-Петербург  
2026

---

## Цель

Разработать компилятор с языка программирования Simple в ассемблер для различных архитектур (x86-64 Linux, x86-64 Windows, RISC-V). Реализовать генерацию кода на основе графа потока управления, поддерживающий основные конструкции языка программирования.

## Задачи

1. **Реализовать парсер языка Simple**
   - 1.1. Разработать синтаксический анализатор для языка Simple
   - 1.2. Построить абстрактное синтаксическое дерево (AST)
   - 1.3. Реализовать семантический анализ и проверку типов

2. **Создать систему генерации кода**
   - 2.1. Реализовать построение графа потока управления (CFG)
   - 2.2. Разработать генераторы ассемблерного кода для x86-64 Linux
   - 2.3. Реализовать генерацию кода для x86-64 Windows
   - 2.4. Создать генератор для архитектуры RISC-V

3. **Поддержать основные конструкции языка**
   - 3.1. Арифметические и логические операции
   - 3.2. Условные операторы (if-else if-else)
   - 3.3. Циклы (while, do-while, for)
   - 3.4. Функции и вызовы встроенных функций

4. **Обеспечить кросс-платформенность**
   - 4.1. Реализовать абстракцию над целевыми платформами
   - 4.2. Обеспечить совместимость с системными вызовами
   - 4.3. Поддержать различные конвенции вызовов

## Ход работы

### 1. Разработка парсера языка Simple

Был реализован лексический и синтаксический анализатор для языка Simple. Язык поддерживает следующий синтаксис:

**Листинг 1 – Пример программы на языке Simple**
```
function fibonacci() -> int {
    variable a -> int;
    variable b -> int;
    variable temp -> int;
    variable n -> int;
    
    a = 0;
    b = 1;
    n = 10;
    
    while (n > 0) {
        printf("%d\n", a);
        temp = a + b;
        a = b;
        b = temp;
        n = n - 1;
    }
    
    return a;
}

function main() -> int {
    return fibonacci();
}
```

Парсер строит AST, который затем преобразуется в граф потока управления (CFG). 

### 2. Генерация графа потока управления

На основе AST строится CFG, состоящий из базовых блоков. Каждый базовый блок содержит последовательность операций и переходы к другим блокам.

**Листинг 2 – Структура базового блока**
```python
@dataclass
class BasicBlock:
    id: int
    operations: List[Operation] = field(default_factory=list)
    true_branch: Optional['BasicBlock'] = None
    false_branch: Optional['BasicBlock'] = None
    next_block: Optional['BasicBlock'] = None
    is_loop_start: bool = False
    is_loop_end: bool = False
```

Операции в базовых блоках представляют собой преобразованные AST-узлы в промежуточное представление.

### 3. Генераторы ассемблерного кода

Реализованы три генератора кода для различных архитектур:

#### 3.1. Генератор для x86-64 Linux

Использует синтаксис NASM и системные вызовы Linux. Основные особенности:
- Использует регистры RAX, RBX, RCX, RDX для вычислений
- Системные вызовы через syscall для ввода/вывода
- Стандартная конвенция вызовов System V ABI

**Листинг 3 – Пример генерации кода для Linux**
```nasm
section .text
global main

main:
    push rbp
    mov rbp, rsp
    
    ; Выделение места для локальных переменных
    sub rsp, 32
    
    ; a = 0
    mov qword [rbp-8], 0
    
    ; b = 1  
    mov qword [rbp-16], 1
    
    ; Цикл while
while_start:
    ; Условие n > 0
    mov rax, [rbp-24]
    test rax, rax
    jle while_end
    
    ; Тело цикла
    ; printf("%d\n", a)
    mov rdi, format_int
    mov rsi, [rbp-8]
    mov rax, 0
    call printf
    
    jmp while_start
while_end:
    
    mov rsp, rbp
    pop rbp
    ret
```

#### 3.2. Генератор для x86-64 Windows

Использует синтаксис MASM и Windows API. Ключевые отличия:
- Использование регистров RAX, RCX, RDX, R8, R9 для аргументов
- Вызовы Windows API вместо syscall
- Другая конвенция вызовов (Microsoft x64)

#### 3.3. Генератор для RISC-V

Генерирует код в формате GCC для архитектуры RISC-V:
- Использует регистры x0-x31
- Системные вызовы через ecall
- Простая конвенция вызовов RISC-V

**Листинг 4 – Пример генерации кода для RISC-V**
```gas
.text
.global main

main:
    ; Сохранение фрейма
    addi sp, sp, -32
    sw ra, 28(sp)
    sw fp, 24(sp)
    addi fp, sp, 32
    
    ; a = 0
    li t0, 0
    sw t0, -8(fp)
    
    ; b = 1
    li t0, 1
    sw t0, -16(fp)
    
    ; Цикл while
while_start:
    ; Условие n > 0
    lw t0, -24(fp)
    blez t0, while_end
    
    ; printf("%d\n", a)
    lw a0, -8(fp)
    la a1, format_int
    li a7, 93  # syscall number for printf
    ecall
    
    j while_start
while_end:
    
    ; Восстановление фрейма
    lw ra, 28(sp)
    lw fp, 24(sp)
    addi sp, sp, 32
    ret
```

### 4. Обработка управляющих конструкций

Реализована поддержка всех основных управляющих конструкций:

#### 4.1. Условные операторы

**Листинг 5 – Пример обработки if-else**
```python
def _process_if_statement(self, if_node: ASTNode, current_block: BasicBlock,
                         func_name: str, file_name: str, exit_block: BasicBlock) -> Optional[BasicBlock]:
    condition_block = current_block
    true_block = self._create_block()
    false_block = self._create_block()
    merge_block = self._create_block()
    
    # Установка переходов
    condition_block.true_branch = true_block
    condition_block.false_branch = false_block
    
    # Обработка веток
    self._process_statements(if_node.children[1], true_block, func_name, file_name, exit_block)
    
    if len(if_node.children) > 2:
        self._process_statements(if_node.children[2], false_block, func_name, file_name, exit_block)
    
    true_block.next_block = merge_block
    false_block.next_block = merge_block
    
    return merge_block
```

#### 4.2. Циклы

Поддерживаются три вида циклов: while, do-while, for. Каждый цикл создает специальную структуру в CFG с базовыми блоками для начала, тела и конца цикла.

### 5. Система типов и встроенные функции

Реализована простая система типов, поддерживающая:
- Целочисленный тип (int)
- Вещественный тип (float)  
- Строковый тип (string)
- Массивы

Поддерживаются встроенные функции:
- `printf()` - форматированный вывод
- `scanf()` - форматированный ввод
- `malloc()` - выделение памяти
- `free()` - освобождение памяти

### 6. Тестирование и результаты

Компилятор был протестирован на нескольких примерах:

1. **Калькулятор** - программа, выполняющая основные арифметические операции
2. **Числа Фибоначчи** - рекурсивное и итеративное вычисление
3. **Сортировка массива** - демонстрация работы с массивами

**Рисунок 1 – Граф потока управления для программы калькулятора**

[Здесь был бы график CFG]

Все примеры успешно компилируются и выполняются на всех трех поддерживаемых платформах.

### 7. Сборка и использование

Для сборки проекта используется Makefile. Основные команды:

```bash
# Сборка всех примеров для всех платформ
make all

# Сборка калькулятора для Linux
make calculator-linux
./build/calculator_linux

# Сборка для RISC-V
make calculator-riscv
qemu-riscv64 build/calculator_riscv

# Очистка
make clean
```

## Выводы

В ходе лабораторной работы был успешно разработан компилятор с языка Simple в ассемблер для трех архитектур. Основные достижения:

1. Реализован полный цикл компиляции: от исходного кода до исполняемого файла
2. Поддерживаются основные конструкции языка программирования
3. Обеспечена кросс-платформенность за счет абстрагирования от целевой архитектуры
4. Продемонстрирована эффективность использования графа потока управления для генерации кода

Компилятор может быть использован для изучения принципов работы компиляторов и для дальнейшего развития в поддержки более сложных конструкций языка.

---

______________ / М.С. Маршалов

______________ / Ю.Д. Кореньков